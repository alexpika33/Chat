{"ast":null,"code":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { Encoder, Decoder } from \"@msgpack/msgpack\";\nimport { LogLevel, MessageType, NullLogger, TransferFormat } from \"@microsoft/signalr\";\nimport { BinaryMessageFormat } from \"./BinaryMessageFormat\";\nimport { isArrayBuffer } from \"./Utils\"; // TypeDoc's @inheritDoc and @link don't work across modules :(\n// constant encoding of the ping message\n// see: https://github.com/aspnet/SignalR/blob/dev/specs/HubProtocol.md#ping-message-encoding-1\n// Don't use Uint8Array.from as IE does not support it\n\nconst SERIALIZED_PING_MESSAGE = new Uint8Array([0x91, MessageType.Ping]);\n/** Implements the MessagePack Hub Protocol */\n\nexport class MessagePackHubProtocol {\n  /**\r\n   *\r\n   * @param messagePackOptions MessagePack options passed to @msgpack/msgpack\r\n   */\n  constructor(messagePackOptions) {\n    /** The name of the protocol. This is used by SignalR to resolve the protocol between the client and server. */\n    this.name = \"messagepack\";\n    /** The version of the protocol. */\n\n    this.version = 1;\n    /** The TransferFormat of the protocol. */\n\n    this.transferFormat = TransferFormat.Binary;\n    this._errorResult = 1;\n    this._voidResult = 2;\n    this._nonVoidResult = 3;\n    messagePackOptions = messagePackOptions || {};\n    this._encoder = new Encoder(messagePackOptions.extensionCodec, messagePackOptions.context, messagePackOptions.maxDepth, messagePackOptions.initialBufferSize, messagePackOptions.sortKeys, messagePackOptions.forceFloat32, messagePackOptions.ignoreUndefined, messagePackOptions.forceIntegerToFloat);\n    this._decoder = new Decoder(messagePackOptions.extensionCodec, messagePackOptions.context, messagePackOptions.maxStrLength, messagePackOptions.maxBinLength, messagePackOptions.maxArrayLength, messagePackOptions.maxMapLength, messagePackOptions.maxExtLength);\n  }\n  /** Creates an array of HubMessage objects from the specified serialized representation.\r\n   *\r\n   * @param {ArrayBuffer} input An ArrayBuffer containing the serialized representation.\r\n   * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n   */\n\n\n  parseMessages(input, logger) {\n    // The interface does allow \"string\" to be passed in, but this implementation does not. So let's throw a useful error.\n    if (!isArrayBuffer(input)) {\n      throw new Error(\"Invalid input for MessagePack hub protocol. Expected an ArrayBuffer.\");\n    }\n\n    if (logger === null) {\n      logger = NullLogger.instance;\n    }\n\n    const messages = BinaryMessageFormat.parse(input);\n    const hubMessages = [];\n\n    for (const message of messages) {\n      const parsedMessage = this._parseMessage(message, logger); // Can be null for an unknown message. Unknown message is logged in parseMessage\n\n\n      if (parsedMessage) {\n        hubMessages.push(parsedMessage);\n      }\n    }\n\n    return hubMessages;\n  }\n  /** Writes the specified HubMessage to an ArrayBuffer and returns it.\r\n   *\r\n   * @param {HubMessage} message The message to write.\r\n   * @returns {ArrayBuffer} An ArrayBuffer containing the serialized representation of the message.\r\n   */\n\n\n  writeMessage(message) {\n    switch (message.type) {\n      case MessageType.Invocation:\n        return this._writeInvocation(message);\n\n      case MessageType.StreamInvocation:\n        return this._writeStreamInvocation(message);\n\n      case MessageType.StreamItem:\n        return this._writeStreamItem(message);\n\n      case MessageType.Completion:\n        return this._writeCompletion(message);\n\n      case MessageType.Ping:\n        return BinaryMessageFormat.write(SERIALIZED_PING_MESSAGE);\n\n      case MessageType.CancelInvocation:\n        return this._writeCancelInvocation(message);\n\n      default:\n        throw new Error(\"Invalid message type.\");\n    }\n  }\n\n  _parseMessage(input, logger) {\n    if (input.length === 0) {\n      throw new Error(\"Invalid payload.\");\n    }\n\n    const properties = this._decoder.decode(input);\n\n    if (properties.length === 0 || !(properties instanceof Array)) {\n      throw new Error(\"Invalid payload.\");\n    }\n\n    const messageType = properties[0];\n\n    switch (messageType) {\n      case MessageType.Invocation:\n        return this._createInvocationMessage(this._readHeaders(properties), properties);\n\n      case MessageType.StreamItem:\n        return this._createStreamItemMessage(this._readHeaders(properties), properties);\n\n      case MessageType.Completion:\n        return this._createCompletionMessage(this._readHeaders(properties), properties);\n\n      case MessageType.Ping:\n        return this._createPingMessage(properties);\n\n      case MessageType.Close:\n        return this._createCloseMessage(properties);\n\n      default:\n        // Future protocol changes can add message types, old clients can ignore them\n        logger.log(LogLevel.Information, \"Unknown message type '\" + messageType + \"' ignored.\");\n        return null;\n    }\n  }\n\n  _createCloseMessage(properties) {\n    // check minimum length to allow protocol to add items to the end of objects in future releases\n    if (properties.length < 2) {\n      throw new Error(\"Invalid payload for Close message.\");\n    }\n\n    return {\n      // Close messages have no headers.\n      allowReconnect: properties.length >= 3 ? properties[2] : undefined,\n      error: properties[1],\n      type: MessageType.Close\n    };\n  }\n\n  _createPingMessage(properties) {\n    // check minimum length to allow protocol to add items to the end of objects in future releases\n    if (properties.length < 1) {\n      throw new Error(\"Invalid payload for Ping message.\");\n    }\n\n    return {\n      // Ping messages have no headers.\n      type: MessageType.Ping\n    };\n  }\n\n  _createInvocationMessage(headers, properties) {\n    // check minimum length to allow protocol to add items to the end of objects in future releases\n    if (properties.length < 5) {\n      throw new Error(\"Invalid payload for Invocation message.\");\n    }\n\n    const invocationId = properties[2];\n\n    if (invocationId) {\n      return {\n        arguments: properties[4],\n        headers,\n        invocationId,\n        streamIds: [],\n        target: properties[3],\n        type: MessageType.Invocation\n      };\n    } else {\n      return {\n        arguments: properties[4],\n        headers,\n        streamIds: [],\n        target: properties[3],\n        type: MessageType.Invocation\n      };\n    }\n  }\n\n  _createStreamItemMessage(headers, properties) {\n    // check minimum length to allow protocol to add items to the end of objects in future releases\n    if (properties.length < 4) {\n      throw new Error(\"Invalid payload for StreamItem message.\");\n    }\n\n    return {\n      headers,\n      invocationId: properties[2],\n      item: properties[3],\n      type: MessageType.StreamItem\n    };\n  }\n\n  _createCompletionMessage(headers, properties) {\n    // check minimum length to allow protocol to add items to the end of objects in future releases\n    if (properties.length < 4) {\n      throw new Error(\"Invalid payload for Completion message.\");\n    }\n\n    const resultKind = properties[3];\n\n    if (resultKind !== this._voidResult && properties.length < 5) {\n      throw new Error(\"Invalid payload for Completion message.\");\n    }\n\n    let error;\n    let result;\n\n    switch (resultKind) {\n      case this._errorResult:\n        error = properties[4];\n        break;\n\n      case this._nonVoidResult:\n        result = properties[4];\n        break;\n    }\n\n    const completionMessage = {\n      error,\n      headers,\n      invocationId: properties[2],\n      result,\n      type: MessageType.Completion\n    };\n    return completionMessage;\n  }\n\n  _writeInvocation(invocationMessage) {\n    let payload;\n\n    if (invocationMessage.streamIds) {\n      payload = this._encoder.encode([MessageType.Invocation, invocationMessage.headers || {}, invocationMessage.invocationId || null, invocationMessage.target, invocationMessage.arguments, invocationMessage.streamIds]);\n    } else {\n      payload = this._encoder.encode([MessageType.Invocation, invocationMessage.headers || {}, invocationMessage.invocationId || null, invocationMessage.target, invocationMessage.arguments]);\n    }\n\n    return BinaryMessageFormat.write(payload.slice());\n  }\n\n  _writeStreamInvocation(streamInvocationMessage) {\n    let payload;\n\n    if (streamInvocationMessage.streamIds) {\n      payload = this._encoder.encode([MessageType.StreamInvocation, streamInvocationMessage.headers || {}, streamInvocationMessage.invocationId, streamInvocationMessage.target, streamInvocationMessage.arguments, streamInvocationMessage.streamIds]);\n    } else {\n      payload = this._encoder.encode([MessageType.StreamInvocation, streamInvocationMessage.headers || {}, streamInvocationMessage.invocationId, streamInvocationMessage.target, streamInvocationMessage.arguments]);\n    }\n\n    return BinaryMessageFormat.write(payload.slice());\n  }\n\n  _writeStreamItem(streamItemMessage) {\n    const payload = this._encoder.encode([MessageType.StreamItem, streamItemMessage.headers || {}, streamItemMessage.invocationId, streamItemMessage.item]);\n\n    return BinaryMessageFormat.write(payload.slice());\n  }\n\n  _writeCompletion(completionMessage) {\n    const resultKind = completionMessage.error ? this._errorResult : completionMessage.result ? this._nonVoidResult : this._voidResult;\n    let payload;\n\n    switch (resultKind) {\n      case this._errorResult:\n        payload = this._encoder.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind, completionMessage.error]);\n        break;\n\n      case this._voidResult:\n        payload = this._encoder.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind]);\n        break;\n\n      case this._nonVoidResult:\n        payload = this._encoder.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind, completionMessage.result]);\n        break;\n    }\n\n    return BinaryMessageFormat.write(payload.slice());\n  }\n\n  _writeCancelInvocation(cancelInvocationMessage) {\n    const payload = this._encoder.encode([MessageType.CancelInvocation, cancelInvocationMessage.headers || {}, cancelInvocationMessage.invocationId]);\n\n    return BinaryMessageFormat.write(payload.slice());\n  }\n\n  _readHeaders(properties) {\n    const headers = properties[1];\n\n    if (typeof headers !== \"object\") {\n      throw new Error(\"Invalid headers.\");\n    }\n\n    return headers;\n  }\n\n}","map":{"version":3,"names":["Encoder","Decoder","LogLevel","MessageType","NullLogger","TransferFormat","BinaryMessageFormat","isArrayBuffer","SERIALIZED_PING_MESSAGE","Uint8Array","Ping","MessagePackHubProtocol","constructor","messagePackOptions","name","version","transferFormat","Binary","_errorResult","_voidResult","_nonVoidResult","_encoder","extensionCodec","context","maxDepth","initialBufferSize","sortKeys","forceFloat32","ignoreUndefined","forceIntegerToFloat","_decoder","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","parseMessages","input","logger","Error","instance","messages","parse","hubMessages","message","parsedMessage","_parseMessage","push","writeMessage","type","Invocation","_writeInvocation","StreamInvocation","_writeStreamInvocation","StreamItem","_writeStreamItem","Completion","_writeCompletion","write","CancelInvocation","_writeCancelInvocation","length","properties","decode","Array","messageType","_createInvocationMessage","_readHeaders","_createStreamItemMessage","_createCompletionMessage","_createPingMessage","Close","_createCloseMessage","log","Information","allowReconnect","undefined","error","headers","invocationId","arguments","streamIds","target","item","resultKind","result","completionMessage","invocationMessage","payload","encode","slice","streamInvocationMessage","streamItemMessage","cancelInvocationMessage"],"sources":["D:/Source/Repos/Chat/Try3/UI/ClientApp/node_modules/@microsoft/signalr-protocol-msgpack/dist/esm/MessagePackHubProtocol.js"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { Encoder, Decoder } from \"@msgpack/msgpack\";\r\nimport { LogLevel, MessageType, NullLogger, TransferFormat, } from \"@microsoft/signalr\";\r\nimport { BinaryMessageFormat } from \"./BinaryMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n// TypeDoc's @inheritDoc and @link don't work across modules :(\r\n// constant encoding of the ping message\r\n// see: https://github.com/aspnet/SignalR/blob/dev/specs/HubProtocol.md#ping-message-encoding-1\r\n// Don't use Uint8Array.from as IE does not support it\r\nconst SERIALIZED_PING_MESSAGE = new Uint8Array([0x91, MessageType.Ping]);\r\n/** Implements the MessagePack Hub Protocol */\r\nexport class MessagePackHubProtocol {\r\n    /**\r\n     *\r\n     * @param messagePackOptions MessagePack options passed to @msgpack/msgpack\r\n     */\r\n    constructor(messagePackOptions) {\r\n        /** The name of the protocol. This is used by SignalR to resolve the protocol between the client and server. */\r\n        this.name = \"messagepack\";\r\n        /** The version of the protocol. */\r\n        this.version = 1;\r\n        /** The TransferFormat of the protocol. */\r\n        this.transferFormat = TransferFormat.Binary;\r\n        this._errorResult = 1;\r\n        this._voidResult = 2;\r\n        this._nonVoidResult = 3;\r\n        messagePackOptions = messagePackOptions || {};\r\n        this._encoder = new Encoder(messagePackOptions.extensionCodec, messagePackOptions.context, messagePackOptions.maxDepth, messagePackOptions.initialBufferSize, messagePackOptions.sortKeys, messagePackOptions.forceFloat32, messagePackOptions.ignoreUndefined, messagePackOptions.forceIntegerToFloat);\r\n        this._decoder = new Decoder(messagePackOptions.extensionCodec, messagePackOptions.context, messagePackOptions.maxStrLength, messagePackOptions.maxBinLength, messagePackOptions.maxArrayLength, messagePackOptions.maxMapLength, messagePackOptions.maxExtLength);\r\n    }\r\n    /** Creates an array of HubMessage objects from the specified serialized representation.\r\n     *\r\n     * @param {ArrayBuffer} input An ArrayBuffer containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    parseMessages(input, logger) {\r\n        // The interface does allow \"string\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (!(isArrayBuffer(input))) {\r\n            throw new Error(\"Invalid input for MessagePack hub protocol. Expected an ArrayBuffer.\");\r\n        }\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n        const messages = BinaryMessageFormat.parse(input);\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = this._parseMessage(message, logger);\r\n            // Can be null for an unknown message. Unknown message is logged in parseMessage\r\n            if (parsedMessage) {\r\n                hubMessages.push(parsedMessage);\r\n            }\r\n        }\r\n        return hubMessages;\r\n    }\r\n    /** Writes the specified HubMessage to an ArrayBuffer and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {ArrayBuffer} An ArrayBuffer containing the serialized representation of the message.\r\n     */\r\n    writeMessage(message) {\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n                return this._writeInvocation(message);\r\n            case MessageType.StreamInvocation:\r\n                return this._writeStreamInvocation(message);\r\n            case MessageType.StreamItem:\r\n                return this._writeStreamItem(message);\r\n            case MessageType.Completion:\r\n                return this._writeCompletion(message);\r\n            case MessageType.Ping:\r\n                return BinaryMessageFormat.write(SERIALIZED_PING_MESSAGE);\r\n            case MessageType.CancelInvocation:\r\n                return this._writeCancelInvocation(message);\r\n            default:\r\n                throw new Error(\"Invalid message type.\");\r\n        }\r\n    }\r\n    _parseMessage(input, logger) {\r\n        if (input.length === 0) {\r\n            throw new Error(\"Invalid payload.\");\r\n        }\r\n        const properties = this._decoder.decode(input);\r\n        if (properties.length === 0 || !(properties instanceof Array)) {\r\n            throw new Error(\"Invalid payload.\");\r\n        }\r\n        const messageType = properties[0];\r\n        switch (messageType) {\r\n            case MessageType.Invocation:\r\n                return this._createInvocationMessage(this._readHeaders(properties), properties);\r\n            case MessageType.StreamItem:\r\n                return this._createStreamItemMessage(this._readHeaders(properties), properties);\r\n            case MessageType.Completion:\r\n                return this._createCompletionMessage(this._readHeaders(properties), properties);\r\n            case MessageType.Ping:\r\n                return this._createPingMessage(properties);\r\n            case MessageType.Close:\r\n                return this._createCloseMessage(properties);\r\n            default:\r\n                // Future protocol changes can add message types, old clients can ignore them\r\n                logger.log(LogLevel.Information, \"Unknown message type '\" + messageType + \"' ignored.\");\r\n                return null;\r\n        }\r\n    }\r\n    _createCloseMessage(properties) {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 2) {\r\n            throw new Error(\"Invalid payload for Close message.\");\r\n        }\r\n        return {\r\n            // Close messages have no headers.\r\n            allowReconnect: properties.length >= 3 ? properties[2] : undefined,\r\n            error: properties[1],\r\n            type: MessageType.Close,\r\n        };\r\n    }\r\n    _createPingMessage(properties) {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 1) {\r\n            throw new Error(\"Invalid payload for Ping message.\");\r\n        }\r\n        return {\r\n            // Ping messages have no headers.\r\n            type: MessageType.Ping,\r\n        };\r\n    }\r\n    _createInvocationMessage(headers, properties) {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 5) {\r\n            throw new Error(\"Invalid payload for Invocation message.\");\r\n        }\r\n        const invocationId = properties[2];\r\n        if (invocationId) {\r\n            return {\r\n                arguments: properties[4],\r\n                headers,\r\n                invocationId,\r\n                streamIds: [],\r\n                target: properties[3],\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                arguments: properties[4],\r\n                headers,\r\n                streamIds: [],\r\n                target: properties[3],\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n    }\r\n    _createStreamItemMessage(headers, properties) {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 4) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n        return {\r\n            headers,\r\n            invocationId: properties[2],\r\n            item: properties[3],\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n    _createCompletionMessage(headers, properties) {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 4) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        const resultKind = properties[3];\r\n        if (resultKind !== this._voidResult && properties.length < 5) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        let error;\r\n        let result;\r\n        switch (resultKind) {\r\n            case this._errorResult:\r\n                error = properties[4];\r\n                break;\r\n            case this._nonVoidResult:\r\n                result = properties[4];\r\n                break;\r\n        }\r\n        const completionMessage = {\r\n            error,\r\n            headers,\r\n            invocationId: properties[2],\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n        return completionMessage;\r\n    }\r\n    _writeInvocation(invocationMessage) {\r\n        let payload;\r\n        if (invocationMessage.streamIds) {\r\n            payload = this._encoder.encode([MessageType.Invocation, invocationMessage.headers || {}, invocationMessage.invocationId || null,\r\n                invocationMessage.target, invocationMessage.arguments, invocationMessage.streamIds]);\r\n        }\r\n        else {\r\n            payload = this._encoder.encode([MessageType.Invocation, invocationMessage.headers || {}, invocationMessage.invocationId || null,\r\n                invocationMessage.target, invocationMessage.arguments]);\r\n        }\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n    _writeStreamInvocation(streamInvocationMessage) {\r\n        let payload;\r\n        if (streamInvocationMessage.streamIds) {\r\n            payload = this._encoder.encode([MessageType.StreamInvocation, streamInvocationMessage.headers || {}, streamInvocationMessage.invocationId,\r\n                streamInvocationMessage.target, streamInvocationMessage.arguments, streamInvocationMessage.streamIds]);\r\n        }\r\n        else {\r\n            payload = this._encoder.encode([MessageType.StreamInvocation, streamInvocationMessage.headers || {}, streamInvocationMessage.invocationId,\r\n                streamInvocationMessage.target, streamInvocationMessage.arguments]);\r\n        }\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n    _writeStreamItem(streamItemMessage) {\r\n        const payload = this._encoder.encode([MessageType.StreamItem, streamItemMessage.headers || {}, streamItemMessage.invocationId,\r\n            streamItemMessage.item]);\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n    _writeCompletion(completionMessage) {\r\n        const resultKind = completionMessage.error ? this._errorResult : completionMessage.result ? this._nonVoidResult : this._voidResult;\r\n        let payload;\r\n        switch (resultKind) {\r\n            case this._errorResult:\r\n                payload = this._encoder.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind, completionMessage.error]);\r\n                break;\r\n            case this._voidResult:\r\n                payload = this._encoder.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind]);\r\n                break;\r\n            case this._nonVoidResult:\r\n                payload = this._encoder.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind, completionMessage.result]);\r\n                break;\r\n        }\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n    _writeCancelInvocation(cancelInvocationMessage) {\r\n        const payload = this._encoder.encode([MessageType.CancelInvocation, cancelInvocationMessage.headers || {}, cancelInvocationMessage.invocationId]);\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    }\r\n    _readHeaders(properties) {\r\n        const headers = properties[1];\r\n        if (typeof headers !== \"object\") {\r\n            throw new Error(\"Invalid headers.\");\r\n        }\r\n        return headers;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}