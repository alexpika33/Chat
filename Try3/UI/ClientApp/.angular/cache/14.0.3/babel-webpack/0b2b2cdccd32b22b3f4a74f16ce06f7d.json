{"ast":null,"code":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// Not exported from index.\n\n/** @private */\nexport class BinaryMessageFormat {\n  // The length prefix of binary messages is encoded as VarInt. Read the comment in\n  // the BinaryMessageParser.TryParseMessage for details.\n  static write(output) {\n    let size = output.byteLength || output.length;\n    const lenBuffer = [];\n\n    do {\n      let sizePart = size & 0x7f;\n      size = size >> 7;\n\n      if (size > 0) {\n        sizePart |= 0x80;\n      }\n\n      lenBuffer.push(sizePart);\n    } while (size > 0);\n\n    size = output.byteLength || output.length;\n    const buffer = new Uint8Array(lenBuffer.length + size);\n    buffer.set(lenBuffer, 0);\n    buffer.set(output, lenBuffer.length);\n    return buffer.buffer;\n  }\n\n  static parse(input) {\n    const result = [];\n    const uint8Array = new Uint8Array(input);\n    const maxLengthPrefixSize = 5;\n    const numBitsToShift = [0, 7, 14, 21, 28];\n\n    for (let offset = 0; offset < input.byteLength;) {\n      let numBytes = 0;\n      let size = 0;\n      let byteRead;\n\n      do {\n        byteRead = uint8Array[offset + numBytes];\n        size = size | (byteRead & 0x7f) << numBitsToShift[numBytes];\n        numBytes++;\n      } while (numBytes < Math.min(maxLengthPrefixSize, input.byteLength - offset) && (byteRead & 0x80) !== 0);\n\n      if ((byteRead & 0x80) !== 0 && numBytes < maxLengthPrefixSize) {\n        throw new Error(\"Cannot read message size.\");\n      }\n\n      if (numBytes === maxLengthPrefixSize && byteRead > 7) {\n        throw new Error(\"Messages bigger than 2GB are not supported.\");\n      }\n\n      if (uint8Array.byteLength >= offset + numBytes + size) {\n        // IE does not support .slice() so use subarray\n        result.push(uint8Array.slice ? uint8Array.slice(offset + numBytes, offset + numBytes + size) : uint8Array.subarray(offset + numBytes, offset + numBytes + size));\n      } else {\n        throw new Error(\"Incomplete message.\");\n      }\n\n      offset = offset + numBytes + size;\n    }\n\n    return result;\n  }\n\n}","map":{"version":3,"names":["BinaryMessageFormat","write","output","size","byteLength","length","lenBuffer","sizePart","push","buffer","Uint8Array","set","parse","input","result","uint8Array","maxLengthPrefixSize","numBitsToShift","offset","numBytes","byteRead","Math","min","Error","slice","subarray"],"sources":["D:/Source/Repos/Chat/Try3/UI/ClientApp/node_modules/@microsoft/signalr-protocol-msgpack/dist/esm/BinaryMessageFormat.js"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n// Not exported from index.\r\n/** @private */\r\nexport class BinaryMessageFormat {\r\n    // The length prefix of binary messages is encoded as VarInt. Read the comment in\r\n    // the BinaryMessageParser.TryParseMessage for details.\r\n    static write(output) {\r\n        let size = output.byteLength || output.length;\r\n        const lenBuffer = [];\r\n        do {\r\n            let sizePart = size & 0x7f;\r\n            size = size >> 7;\r\n            if (size > 0) {\r\n                sizePart |= 0x80;\r\n            }\r\n            lenBuffer.push(sizePart);\r\n        } while (size > 0);\r\n        size = output.byteLength || output.length;\r\n        const buffer = new Uint8Array(lenBuffer.length + size);\r\n        buffer.set(lenBuffer, 0);\r\n        buffer.set(output, lenBuffer.length);\r\n        return buffer.buffer;\r\n    }\r\n    static parse(input) {\r\n        const result = [];\r\n        const uint8Array = new Uint8Array(input);\r\n        const maxLengthPrefixSize = 5;\r\n        const numBitsToShift = [0, 7, 14, 21, 28];\r\n        for (let offset = 0; offset < input.byteLength;) {\r\n            let numBytes = 0;\r\n            let size = 0;\r\n            let byteRead;\r\n            do {\r\n                byteRead = uint8Array[offset + numBytes];\r\n                size = size | ((byteRead & 0x7f) << (numBitsToShift[numBytes]));\r\n                numBytes++;\r\n            } while (numBytes < Math.min(maxLengthPrefixSize, input.byteLength - offset) && (byteRead & 0x80) !== 0);\r\n            if ((byteRead & 0x80) !== 0 && numBytes < maxLengthPrefixSize) {\r\n                throw new Error(\"Cannot read message size.\");\r\n            }\r\n            if (numBytes === maxLengthPrefixSize && byteRead > 7) {\r\n                throw new Error(\"Messages bigger than 2GB are not supported.\");\r\n            }\r\n            if (uint8Array.byteLength >= (offset + numBytes + size)) {\r\n                // IE does not support .slice() so use subarray\r\n                result.push(uint8Array.slice\r\n                    ? uint8Array.slice(offset + numBytes, offset + numBytes + size)\r\n                    : uint8Array.subarray(offset + numBytes, offset + numBytes + size));\r\n            }\r\n            else {\r\n                throw new Error(\"Incomplete message.\");\r\n            }\r\n            offset = offset + numBytes + size;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;;AACA;AACA,OAAO,MAAMA,mBAAN,CAA0B;EAC7B;EACA;EACY,OAALC,KAAK,CAACC,MAAD,EAAS;IACjB,IAAIC,IAAI,GAAGD,MAAM,CAACE,UAAP,IAAqBF,MAAM,CAACG,MAAvC;IACA,MAAMC,SAAS,GAAG,EAAlB;;IACA,GAAG;MACC,IAAIC,QAAQ,GAAGJ,IAAI,GAAG,IAAtB;MACAA,IAAI,GAAGA,IAAI,IAAI,CAAf;;MACA,IAAIA,IAAI,GAAG,CAAX,EAAc;QACVI,QAAQ,IAAI,IAAZ;MACH;;MACDD,SAAS,CAACE,IAAV,CAAeD,QAAf;IACH,CAPD,QAOSJ,IAAI,GAAG,CAPhB;;IAQAA,IAAI,GAAGD,MAAM,CAACE,UAAP,IAAqBF,MAAM,CAACG,MAAnC;IACA,MAAMI,MAAM,GAAG,IAAIC,UAAJ,CAAeJ,SAAS,CAACD,MAAV,GAAmBF,IAAlC,CAAf;IACAM,MAAM,CAACE,GAAP,CAAWL,SAAX,EAAsB,CAAtB;IACAG,MAAM,CAACE,GAAP,CAAWT,MAAX,EAAmBI,SAAS,CAACD,MAA7B;IACA,OAAOI,MAAM,CAACA,MAAd;EACH;;EACW,OAALG,KAAK,CAACC,KAAD,EAAQ;IAChB,MAAMC,MAAM,GAAG,EAAf;IACA,MAAMC,UAAU,GAAG,IAAIL,UAAJ,CAAeG,KAAf,CAAnB;IACA,MAAMG,mBAAmB,GAAG,CAA5B;IACA,MAAMC,cAAc,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,EAAP,EAAW,EAAX,EAAe,EAAf,CAAvB;;IACA,KAAK,IAAIC,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGL,KAAK,CAACT,UAApC,GAAiD;MAC7C,IAAIe,QAAQ,GAAG,CAAf;MACA,IAAIhB,IAAI,GAAG,CAAX;MACA,IAAIiB,QAAJ;;MACA,GAAG;QACCA,QAAQ,GAAGL,UAAU,CAACG,MAAM,GAAGC,QAAV,CAArB;QACAhB,IAAI,GAAGA,IAAI,GAAI,CAACiB,QAAQ,GAAG,IAAZ,KAAsBH,cAAc,CAACE,QAAD,CAAnD;QACAA,QAAQ;MACX,CAJD,QAISA,QAAQ,GAAGE,IAAI,CAACC,GAAL,CAASN,mBAAT,EAA8BH,KAAK,CAACT,UAAN,GAAmBc,MAAjD,CAAX,IAAuE,CAACE,QAAQ,GAAG,IAAZ,MAAsB,CAJtG;;MAKA,IAAI,CAACA,QAAQ,GAAG,IAAZ,MAAsB,CAAtB,IAA2BD,QAAQ,GAAGH,mBAA1C,EAA+D;QAC3D,MAAM,IAAIO,KAAJ,CAAU,2BAAV,CAAN;MACH;;MACD,IAAIJ,QAAQ,KAAKH,mBAAb,IAAoCI,QAAQ,GAAG,CAAnD,EAAsD;QAClD,MAAM,IAAIG,KAAJ,CAAU,6CAAV,CAAN;MACH;;MACD,IAAIR,UAAU,CAACX,UAAX,IAA0Bc,MAAM,GAAGC,QAAT,GAAoBhB,IAAlD,EAAyD;QACrD;QACAW,MAAM,CAACN,IAAP,CAAYO,UAAU,CAACS,KAAX,GACNT,UAAU,CAACS,KAAX,CAAiBN,MAAM,GAAGC,QAA1B,EAAoCD,MAAM,GAAGC,QAAT,GAAoBhB,IAAxD,CADM,GAENY,UAAU,CAACU,QAAX,CAAoBP,MAAM,GAAGC,QAA7B,EAAuCD,MAAM,GAAGC,QAAT,GAAoBhB,IAA3D,CAFN;MAGH,CALD,MAMK;QACD,MAAM,IAAIoB,KAAJ,CAAU,qBAAV,CAAN;MACH;;MACDL,MAAM,GAAGA,MAAM,GAAGC,QAAT,GAAoBhB,IAA7B;IACH;;IACD,OAAOW,MAAP;EACH;;AApD4B"},"metadata":{},"sourceType":"module"}