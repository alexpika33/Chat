{"ast":null,"code":"import { utf8DecodeJs } from \"./utils/utf8.mjs\";\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nvar CachedKeyDecoder =\n/** @class */\nfunction () {\n  function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n    if (maxKeyLength === void 0) {\n      maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n    }\n\n    if (maxLengthPerKey === void 0) {\n      maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n    }\n\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n    this.hit = 0;\n    this.miss = 0; // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n\n    this.caches = [];\n\n    for (var i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  };\n\n  CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n    var records = this.caches[byteLength - 1];\n\n    FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n      var record = records_1[_i];\n      var recordBytes = record.bytes;\n\n      for (var j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n\n      return record.str;\n    }\n\n    return null;\n  };\n\n  CachedKeyDecoder.prototype.store = function (bytes, value) {\n    var records = this.caches[bytes.length - 1];\n    var record = {\n      bytes: bytes,\n      str: value\n    };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[Math.random() * records.length | 0] = record;\n    } else {\n      records.push(record);\n    }\n  };\n\n  CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n    var cachedValue = this.find(bytes, inputOffset, byteLength);\n\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n\n    this.miss++;\n    var str = utf8DecodeJs(bytes, inputOffset, byteLength); // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n\n    var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  };\n\n  return CachedKeyDecoder;\n}();\n\nexport { CachedKeyDecoder };","map":{"version":3,"names":["utf8DecodeJs","DEFAULT_MAX_KEY_LENGTH","DEFAULT_MAX_LENGTH_PER_KEY","CachedKeyDecoder","maxKeyLength","maxLengthPerKey","hit","miss","caches","i","push","prototype","canBeCached","byteLength","find","bytes","inputOffset","records","FIND_CHUNK","_i","records_1","length","record","recordBytes","j","str","store","value","Math","random","decode","cachedValue","slicedCopyOfBytes","Uint8Array","slice","call"],"sources":["D:/Source/Repos/Chat/Try3/UI/ClientApp/node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs"],"sourcesContent":["import { utf8DecodeJs } from \"./utils/utf8.mjs\";\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = utf8DecodeJs(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\nexport { CachedKeyDecoder };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}